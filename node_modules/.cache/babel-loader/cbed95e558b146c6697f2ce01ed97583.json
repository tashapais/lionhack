{"ast":null,"code":"import { BinaryReader, BinaryWriter } from 'borsh';\nimport base58 from 'bs58';\nimport * as splToken from '@solana/spl-token';\nimport crypto from 'crypto';\nimport BN from 'bn.js';\nimport { serialize } from 'borsh';\nimport { Keypair, PublicKey, Transaction, clusterApiUrl, SystemProgram, SYSVAR_RENT_PUBKEY, TransactionInstruction } from \"@solana/web3.js\";\nimport { sleepUtil } from './sleepUtil';\nexport const TOKEN_PROGRAM_ID = new PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA');\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\nconst METADATA_PROGRAM_ID = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';\nconst MEMO_ID = new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');\nconst programIds = {\n  token: TOKEN_PROGRAM_ID,\n  associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  metadata: METADATA_PROGRAM_ID,\n  memo: MEMO_ID\n};\nexport const NETWORK = clusterApiUrl(\"devnet\");\nexport const AR_SOL_HOLDER_ID = new PublicKey('HvwC9QSAzvGXhhVrgPmauVwFWcYZhne3hVot9EbHuFTm');\nexport const METADATA_PREFIX = 'metadata';\nexport const EDITION = 'edition';\nexport const EDITION_MARKER_BIT_SIZE = 248;\nexport const DEFAULT_TIMEOUT = 15000;\nexport const RESERVED_TXN_MANIFEST = 'manifest.json';\nexport const MetadataKey = {\n  Uninitialized: 0,\n  MetadataV1: 4,\n  EditionV1: 1,\n  MasterEditionV1: 2,\n  MasterEditionV2: 6,\n  EditionMarker: 7\n};\n\n/**\n * Classes to be used to create the NFT\n */\n\nclass CreateMetadataArgs {\n  constructor(args) {\n    this.instruction = 0;\n    this.data = args.data;\n    this.isMutable = args.isMutable;\n  }\n}\nclass UpdateMetadataArgs {\n  // Not used by this app, just required for instruction\n\n  constructor(args) {\n    this.instruction = 1;\n    this.data = args.data ? args.data : null;\n    this.updateAuthority = args.updateAuthority ? args.updateAuthority : null;\n    this.primarySaleHappened = args.primarySaleHappened;\n  }\n}\nclass CreateMasterEditionArgs {\n  constructor(args) {\n    this.instruction = 10;\n    this.maxSupply = args.maxSupply;\n  }\n}\nclass Edition {\n  /// Points at MasterEdition struct\n\n  /// Starting at 0 for master record, this is incremented for each edition minted.\n\n  constructor(args) {\n    this.key = MetadataKey.EditionV1;\n    this.parent = args.parent;\n    this.edition = args.edition;\n  }\n}\nexport class Creator {\n  constructor(args) {\n    this.address = args.address;\n    this.verified = args.verified;\n    this.share = args.share;\n  }\n}\nclass Data {\n  constructor(args) {\n    this.name = args.name;\n    this.symbol = args.symbol;\n    this.uri = args.uri;\n    this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;\n    this.creators = args.creators;\n  }\n}\nclass Metadata {\n  // set lazy\n\n  constructor(args) {\n    this.key = MetadataKey.MetadataV1;\n    this.updateAuthority = args.updateAuthority;\n    this.mint = args.mint;\n    this.data = args.data;\n    this.primarySaleHappened = args.primarySaleHappened;\n    this.isMutable = args.isMutable;\n    this.editionNonce = args.editionNonce;\n  }\n  async init() {\n    const edition = await getEdition(this.mint);\n    this.edition = edition;\n    this.masterEdition = edition;\n  }\n}\nclass MintPrintingTokensArgs {\n  constructor(args) {\n    this.supply = args.supply;\n  }\n}\nclass MasterEditionV1 {\n  /// Can be used to mint tokens that give one-time permission to mint a single limited edition.\n\n  /// If you don't know how many printing tokens you are going to need, but you do know\n  /// you are going to need some amount in the future, you can use a token from this mint.\n  /// Coming back to token metadata with one of these tokens allows you to mint (one time)\n  /// any number of printing tokens you want. This is used for instance by Auction Manager\n  /// with participation NFTs, where we dont know how many people will bid and need participation\n  /// printing tokens to redeem, so we give it ONE of these tokens to use after the auction is over,\n  /// because when the auction begins we just dont know how many printing tokens we will need,\n  /// but at the end we will. At the end it then burns this token with token-metadata to\n  /// get the printing tokens it needs to give to bidders. Each bidder then redeems a printing token\n  /// to get their limited editions.\n  constructor(args) {\n    this.key = MetadataKey.MasterEditionV1;\n    this.supply = args.supply;\n    this.maxSupply = args.maxSupply;\n    this.printingMint = args.printingMint;\n    this.oneTimePrintingAuthorizationMint = args.oneTimePrintingAuthorizationMint;\n  }\n}\nclass MasterEditionV2 {\n  constructor(args) {\n    this.key = MetadataKey.MasterEditionV2;\n    this.supply = args.supply;\n    this.maxSupply = args.maxSupply;\n  }\n}\nclass EditionMarker {\n  constructor(args) {\n    this.key = MetadataKey.EditionMarker;\n    this.ledger = args.ledger;\n  }\n  editionTaken(edition) {\n    const editionOffset = edition % EDITION_MARKER_BIT_SIZE;\n    const indexOffset = Math.floor(editionOffset / 8);\n    if (indexOffset > 30) {\n      throw Error('bad index for edition');\n    }\n    const positionInBitsetFromRight = 7 - editionOffset % 8;\n    const mask = Math.pow(2, positionInBitsetFromRight);\n    const appliedMask = this.ledger[indexOffset] & mask;\n    return appliedMask != 0;\n  }\n}\n\n/**\n * Helpder function to detect whether Phantom wallet extension installed or not\n * @param {*} connectToWallet \n * @returns \n */\nexport const connectOrGetPhantomProvider = connectToWallet => {\n  if (\"solana\" in window) {\n    const provider = window.solana;\n    if (connectToWallet && !window.solana.isConnected) {\n      window.solana.connect();\n    }\n    if (provider.isPhantom) {\n      return provider;\n    }\n  } else if (connectToWallet) {\n    alert(`Please install the phantom wallet from https://phantom.app/`);\n  }\n};\nexport const connectOrGetPhantomProviderTransient = () => {\n  console.log(' connect connectOrGetPhantomProviderTransient called ');\n  if (\"solana\" in window) {\n    window.solana.connect({\n      onlyIfTrusted: true\n    });\n  }\n};\n\n/**\n * Helper function to convert base64 to file object\n * @param {*} dataurl \n * @param {*} filename \n * @returns \n */\nexport const dataURLtoFile = (dataurl, filename) => {\n  let arr = dataurl.split(','),\n    mime = arr[0].match(/:(.*?);/)[1],\n    bstr = atob(arr[1]),\n    n = bstr.length,\n    u8arr = new Uint8Array(n);\n  while (n--) {\n    u8arr[n] = bstr.charCodeAt(n);\n  }\n  return new File([u8arr], filename, {\n    type: mime\n  });\n};\n\n/**\n * Utility to add functionality to BinaryReader\n */\nexport const extendBorsh = () => {\n  BinaryReader.prototype.readPubkey = function () {\n    const reader = this;\n    const array = reader.readFixedArray(32);\n    return new PublicKey(array);\n  };\n  BinaryWriter.prototype.writePubkey = function (value) {\n    const writer = this;\n    writer.writeFixedArray(value.toBuffer());\n  };\n  BinaryReader.prototype.readPubkeyAsString = function () {\n    const reader = this;\n    const array = reader.readFixedArray(32);\n    return base58.encode(array);\n  };\n  BinaryWriter.prototype.writePubkeyAsString = function (value) {\n    const writer = this;\n    writer.writeFixedArray(base58.decode(value));\n  };\n};\nextendBorsh();\nexport const mintNFT = async function (connection, provider, env, files, metadata) {\n  var _result$messages;\n  const wallet = provider;\n  const metadataContent = {\n    name: metadata.name,\n    symbol: metadata.symbol,\n    description: metadata.description,\n    seller_fee_basis_points: metadata.sellerFeeBasisPoints,\n    image: metadata.image,\n    animation_url: metadata.animation_url,\n    external_url: metadata.external_url,\n    properties: {\n      ...metadata.properties,\n      creators: metadata.creators.map(creator => {\n        return {\n          address: creator.address,\n          share: creator.share\n        };\n      })\n    }\n  };\n  const realFiles = [...files, new File([JSON.stringify(metadataContent)], 'metadata.json')];\n  const {\n    instructions: pushInstructions,\n    signers: pushSigners\n  } = await prepPayForFilesTxn(wallet, realFiles, metadata);\n\n  // Allocate memory for the account\n  const mintRent = await connection.getMinimumBalanceForRentExemption(splToken.MintLayout.span);\n  const payerPublicKey = wallet.publicKey.toBase58();\n  const instructions = [...pushInstructions];\n  const signers = [...pushSigners];\n\n  // This is only temporarily owned by wallet...transferred to program by createMasterEdition below\n  const mintKey = createMint(instructions, wallet.publicKey, mintRent, 0,\n  // Some weird bug with phantom where it's public key doesnt mesh with data encode wellff\n  new PublicKey(payerPublicKey), new PublicKey(payerPublicKey), signers).toBase58();\n  const recipientKey = (await findProgramAddress([wallet.publicKey.toBuffer(), programIds.token.toBuffer(), new PublicKey(mintKey).toBuffer()], programIds.associatedToken))[0];\n  createAssociatedTokenAccountInstruction(instructions, new PublicKey(recipientKey), wallet.publicKey, wallet.publicKey, new PublicKey(mintKey));\n  const classData = new Data({\n    symbol: metadata.symbol,\n    name: metadata.name,\n    uri: ' '.repeat(64),\n    // size of url for arweave\n    sellerFeeBasisPoints: metadata.sellerFeeBasisPoints,\n    creators: metadata.creators\n  });\n  const metadataAccount = await createMetadata(classData, payerPublicKey, mintKey, payerPublicKey, instructions, wallet.publicKey.toBase58());\n  const {\n    txid\n  } = await sendTransactionWithRetry(connection, wallet, instructions, signers);\n  try {\n    // return\n    await connection.confirmTransaction(txid, 'max');\n  } catch {\n    // ignore\n  }\n  await connection.getParsedConfirmedTransaction(txid, 'confirmed');\n  const data = new FormData();\n  const tags = realFiles.reduce((acc, f) => {\n    acc[f.name] = [{\n      name: 'mint',\n      value: mintKey\n    }];\n    return acc;\n  }, {});\n  data.append('tags', JSON.stringify(tags));\n  data.append('transaction', txid);\n  realFiles.map(f => data.append('file[]', f));\n  const result = await (await fetch('https://us-central1-principal-lane-200702.cloudfunctions.net/uploadFile2', {\n    method: 'POST',\n    body: data\n  })).json();\n  const metadataFile = (_result$messages = result.messages) === null || _result$messages === void 0 ? void 0 : _result$messages.find(m => m.filename === RESERVED_TXN_MANIFEST);\n  let arweaveLink = \"\";\n  if (metadataFile !== null && metadataFile !== void 0 && metadataFile.transactionId) {\n    const updateInstructions = [];\n    const updateSigners = [];\n    arweaveLink = `https://arweave.net/${metadataFile.transactionId}`;\n    await updateMetadata(new Data({\n      name: metadata.name,\n      symbol: metadata.symbol,\n      uri: arweaveLink,\n      creators: metadata.creators,\n      sellerFeeBasisPoints: metadata.sellerFeeBasisPoints\n    }), undefined, undefined, mintKey, payerPublicKey, updateInstructions, metadataAccount);\n    updateInstructions.push(splToken.Token.createMintToInstruction(TOKEN_PROGRAM_ID, new PublicKey(mintKey), new PublicKey(recipientKey), new PublicKey(payerPublicKey), [], 1));\n    await createMasterEdition(new BN(1), mintKey, payerPublicKey, payerPublicKey, payerPublicKey, updateInstructions);\n    await sendTransactionWithRetry(connection, wallet, updateInstructions, updateSigners);\n  }\n  return {\n    metadataAccount,\n    arweaveLink,\n    mintKey,\n    account: recipientKey\n  };\n};\n\n//END the mintNFT\n\n/**\n * \n * @param {*} maxSupply \n * @param {*} mintKey \n * @param {*} updateAuthorityKey \n * @param {*} mintAuthorityKey \n * @param {*} payer \n * @param {*} instructions \n */\n\nasync function createMasterEdition(maxSupply, mintKey, updateAuthorityKey, mintAuthorityKey, payer, instructions) {\n  const metadataProgramId = programIds.metadata;\n  const metadataAccount = (await findProgramAddress([Buffer.from(METADATA_PREFIX), new PublicKey(metadataProgramId).toBuffer(), new PublicKey(mintKey).toBuffer()], new PublicKey(metadataProgramId)))[0];\n  const editionAccount = (await findProgramAddress([Buffer.from(METADATA_PREFIX), new PublicKey(metadataProgramId).toBuffer(), new PublicKey(mintKey).toBuffer(), Buffer.from(EDITION)], new PublicKey(metadataProgramId)))[0];\n  const value = new CreateMasterEditionArgs({\n    maxSupply: maxSupply || null\n  });\n  const data = Buffer.from(serialize(METADATA_SCHEMA, value));\n  const keys = [{\n    pubkey: new PublicKey(editionAccount),\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: new PublicKey(mintKey),\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: new PublicKey(updateAuthorityKey),\n    isSigner: true,\n    isWritable: false\n  }, {\n    pubkey: new PublicKey(mintAuthorityKey),\n    isSigner: true,\n    isWritable: false\n  }, {\n    pubkey: new PublicKey(payer),\n    isSigner: true,\n    isWritable: false\n  }, {\n    pubkey: new PublicKey(metadataAccount),\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: programIds.token,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SystemProgram.programId,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SYSVAR_RENT_PUBKEY,\n    isSigner: false,\n    isWritable: false\n  }];\n  instructions.push(new TransactionInstruction({\n    keys,\n    programId: new PublicKey(metadataProgramId),\n    data\n  }));\n}\nconst prepPayForFilesTxn = async (wallet, files, metadata) => {\n  const memo = programIds.memo;\n  const instructions = [];\n  const signers = [];\n  if (wallet.publicKey) instructions.push(SystemProgram.transfer({\n    fromPubkey: wallet.publicKey,\n    toPubkey: AR_SOL_HOLDER_ID,\n    lamports: 100000000\n  }));\n\n  //Already uploading files on IPFS, hence no files to be transacted here\n  for (let i = 0; i < files.length; i++) {\n    const hashSum = crypto.createHash('sha256');\n    hashSum.update(await files[i].text());\n    const hex = hashSum.digest('hex');\n    instructions.push(new TransactionInstruction({\n      keys: [],\n      programId: memo,\n      data: Buffer.from(hex)\n    }));\n  }\n  return {\n    instructions,\n    signers\n  };\n};\nconst findProgramAddress = async (seeds, programId) => {\n  const result = await PublicKey.findProgramAddress(seeds, programId);\n  return [result[0].toBase58(), result[1]];\n};\nfunction createMint(instructions, payer, mintRentExempt, decimals, owner, freezeAuthority, signers) {\n  const account = createUninitializedMint(instructions, payer, mintRentExempt, signers);\n  instructions.push(splToken.Token.createInitMintInstruction(TOKEN_PROGRAM_ID, account, decimals, owner, freezeAuthority));\n  return account;\n}\nconst createTokenAccount = (instructions, payer, accountRentExempt, mint, owner, signers) => {\n  const account = createUninitializedAccount(instructions, payer, accountRentExempt, signers);\n  instructions.push(splToken.Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, account, owner));\n  return account;\n};\nfunction createUninitializedMint(instructions, payer, amount, signers) {\n  const account = Keypair.generate();\n  instructions.push(SystemProgram.createAccount({\n    fromPubkey: payer,\n    newAccountPubkey: account.publicKey,\n    lamports: amount,\n    space: splToken.MintLayout.span,\n    programId: TOKEN_PROGRAM_ID\n  }));\n  signers.push(account);\n  return account.publicKey;\n}\nfunction createUninitializedAccount(instructions, payer, amount, signers) {\n  const account = Keypair.generate();\n  instructions.push(SystemProgram.createAccount({\n    fromPubkey: payer,\n    newAccountPubkey: account.publicKey,\n    lamports: amount,\n    space: splToken.AccountLayout.span,\n    programId: TOKEN_PROGRAM_ID\n  }));\n  signers.push(account);\n  return account.publicKey;\n}\nfunction createAssociatedTokenAccountInstruction(instructions, associatedTokenAddress, payer, walletAddress, splTokenMintAddress) {\n  const keys = [{\n    pubkey: payer,\n    isSigner: true,\n    isWritable: true\n  }, {\n    pubkey: associatedTokenAddress,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: walletAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: splTokenMintAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SystemProgram.programId,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: programIds.token,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SYSVAR_RENT_PUBKEY,\n    isSigner: false,\n    isWritable: false\n  }];\n  instructions.push(new TransactionInstruction({\n    keys,\n    programId: programIds.associatedToken,\n    data: Buffer.from([])\n  }));\n}\nconst sendTransactionWithRetry = async function (connection, wallet, instructions, signers) {\n  let commitment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'singleGossip';\n  let includesFeePayer = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let block = arguments.length > 6 ? arguments[6] : undefined;\n  let beforeSend = arguments.length > 7 ? arguments[7] : undefined;\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (block || (await connection.getRecentBlockhash(commitment))).blockhash;\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n    // fee payed by the wallet owner\n    wallet.publicKey, ...signers.map(s => s.publicKey));\n  }\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n  if (beforeSend) {\n    beforeSend();\n  }\n  const {\n    txid,\n    slot\n  } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction\n  });\n  return {\n    txid,\n    slot\n  };\n};\nconst getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\nasync function awaitTransactionSignatureConfirmation(txid, timeout, connection) {\n  let commitment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'recent';\n  let queryStatus = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let done = false;\n  let status = {\n    slot: 0,\n    confirmations: 0,\n    err: null\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({\n        timeout: true\n      });\n    }, timeout);\n    try {\n      subId = connection.onSignature(txid, (result, context) => {\n        done = true;\n        status = {\n          err: result.err,\n          slot: context.slot,\n          confirmations: 0\n        };\n        if (result.err) {\n          console.log('Rejected via websocket', result.err);\n          reject(status);\n        } else {\n          console.log('Resolved via websocket', result);\n          resolve(status);\n        }\n      }, commitment);\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([txid]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleepUtil(1000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId]) connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\nasync function sendSignedTransaction(_ref) {\n  let {\n    signedTransaction,\n    connection,\n    timeout = DEFAULT_TIMEOUT\n  } = _ref;\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid = await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight: true\n  });\n  console.log('Started awaiting confirmation for', txid);\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true\n      });\n      await sleepUtil(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(txid, timeout, connection, 'recent', true);\n    if (!confirmation) throw new Error('Timed out awaiting confirmation on transaction');\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n    slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;\n  } catch (err) {\n    // console.error('Timeout Error caught', err);\n    // if (err.timeout) {\n    //   throw new Error('Timed out awaiting confirmation on transaction');\n    // }\n    // let simulateResult: SimulatedTransactionResponse | null = null;\n    // try {\n    //   simulateResult = (\n    //     await simulateTransaction(connection, signedTransaction, 'single')\n    //   ).value;\n    // } catch (e) {}\n    // if (simulateResult && simulateResult.err) {\n    //   if (simulateResult.logs) {\n    //     for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n    //       const line = simulateResult.logs[i];\n    //       if (line.startsWith('Program log: ')) {\n    //         throw new Error(\n    //           'Transaction failed: ' + line.slice('Program log: '.length),\n    //         );\n    //       }\n    //     }\n    //   }\n    //   throw new Error(JSON.stringify(simulateResult.err));\n    // }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return {\n    txid,\n    slot\n  };\n}\nasync function getEdition(tokenMint) {\n  return (await findProgramAddress([Buffer.from(METADATA_PREFIX), new PublicKey(programIds.metadata).toBuffer(), new PublicKey(tokenMint).toBuffer(), Buffer.from(EDITION)], new PublicKey(programIds.metadata)))[0];\n}\nconst METADATA_SCHEMA = new Map([[CreateMetadataArgs, {\n  kind: 'struct',\n  fields: [['instruction', 'u8'], ['data', Data], ['isMutable', 'u8'] // bool\n  ]\n}], [UpdateMetadataArgs, {\n  kind: 'struct',\n  fields: [['instruction', 'u8'], ['data', {\n    kind: 'option',\n    type: Data\n  }], ['updateAuthority', {\n    kind: 'option',\n    type: 'pubkeyAsString'\n  }], ['primarySaleHappened', {\n    kind: 'option',\n    type: 'u8'\n  }]]\n}], [CreateMasterEditionArgs, {\n  kind: 'struct',\n  fields: [['instruction', 'u8'], ['maxSupply', {\n    kind: 'option',\n    type: 'u64'\n  }]]\n}], [MintPrintingTokensArgs, {\n  kind: 'struct',\n  fields: [['instruction', 'u8'], ['supply', 'u64']]\n}], [MasterEditionV1, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['supply', 'u64'], ['maxSupply', {\n    kind: 'option',\n    type: 'u64'\n  }], ['printingMint', 'pubkeyAsString'], ['oneTimePrintingAuthorizationMint', 'pubkeyAsString']]\n}], [MasterEditionV2, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['supply', 'u64'], ['maxSupply', {\n    kind: 'option',\n    type: 'u64'\n  }]]\n}], [Edition, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['parent', 'pubkeyAsString'], ['edition', 'u64']]\n}], [Data, {\n  kind: 'struct',\n  fields: [['name', 'string'], ['symbol', 'string'], ['uri', 'string'], ['sellerFeeBasisPoints', 'u16'], ['creators', {\n    kind: 'option',\n    type: [Creator]\n  }]]\n}], [Creator, {\n  kind: 'struct',\n  fields: [['address', 'pubkeyAsString'], ['verified', 'u8'], ['share', 'u8']]\n}], [Metadata, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['updateAuthority', 'pubkeyAsString'], ['mint', 'pubkeyAsString'], ['data', Data], ['primarySaleHappened', 'u8'],\n  // bool\n  ['isMutable', 'u8'] // bool\n  ]\n}], [EditionMarker, {\n  kind: 'struct',\n  fields: [['key', 'u8'], ['ledger', [31]]]\n}]]);\nasync function createMetadata(data, updateAuthority, mintKey, mintAuthorityKey, instructions, payer) {\n  const metadataProgramId = programIds.metadata;\n  const metadataAccount = (await findProgramAddress([Buffer.from('metadata'), new PublicKey(metadataProgramId).toBuffer(), new PublicKey(mintKey).toBuffer()], new PublicKey(metadataProgramId)))[0];\n  const value = new CreateMetadataArgs({\n    data,\n    isMutable: true\n  });\n  let txnData = Buffer.from(serialize(METADATA_SCHEMA, value));\n  ;\n  const keys = [{\n    pubkey: new PublicKey(metadataAccount),\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: new PublicKey(mintKey),\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: new PublicKey(mintAuthorityKey),\n    isSigner: true,\n    isWritable: false\n  }, {\n    pubkey: new PublicKey(payer),\n    isSigner: true,\n    isWritable: false\n  }, {\n    pubkey: new PublicKey(updateAuthority),\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SystemProgram.programId,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SYSVAR_RENT_PUBKEY,\n    isSigner: false,\n    isWritable: false\n  }];\n  instructions.push(new TransactionInstruction({\n    keys,\n    programId: new PublicKey(metadataProgramId),\n    data: txnData\n  }));\n  return metadataAccount;\n}\nasync function updateMetadata(data, newUpdateAuthority, primarySaleHappened, mintKey, updateAuthority, instructions, metadataAccount) {\n  const metadataProgramId = programIds.metadata;\n  metadataAccount = metadataAccount || (await findProgramAddress([Buffer.from('metadata'), new PublicKey(metadataProgramId).toBuffer(), new PublicKey(mintKey).toBuffer()], new PublicKey(metadataProgramId)))[0];\n  const value = new UpdateMetadataArgs({\n    data,\n    updateAuthority: !newUpdateAuthority ? undefined : newUpdateAuthority,\n    primarySaleHappened: primarySaleHappened === null || primarySaleHappened === undefined ? null : primarySaleHappened\n  });\n  const txnData = Buffer.from(serialize(METADATA_SCHEMA, value));\n  const keys = [{\n    pubkey: new PublicKey(metadataAccount),\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: new PublicKey(updateAuthority),\n    isSigner: true,\n    isWritable: false\n  }];\n  instructions.push(new TransactionInstruction({\n    keys,\n    programId: new PublicKey(metadataProgramId),\n    data: txnData\n  }));\n  return metadataAccount;\n}","map":{"version":3,"names":["BinaryReader","BinaryWriter","base58","splToken","crypto","BN","serialize","Keypair","PublicKey","Transaction","clusterApiUrl","SystemProgram","SYSVAR_RENT_PUBKEY","TransactionInstruction","sleepUtil","TOKEN_PROGRAM_ID","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","METADATA_PROGRAM_ID","MEMO_ID","programIds","token","associatedToken","metadata","memo","NETWORK","AR_SOL_HOLDER_ID","METADATA_PREFIX","EDITION","EDITION_MARKER_BIT_SIZE","DEFAULT_TIMEOUT","RESERVED_TXN_MANIFEST","MetadataKey","Uninitialized","MetadataV1","EditionV1","MasterEditionV1","MasterEditionV2","EditionMarker","CreateMetadataArgs","constructor","args","instruction","data","isMutable","UpdateMetadataArgs","updateAuthority","primarySaleHappened","CreateMasterEditionArgs","maxSupply","Edition","key","parent","edition","Creator","address","verified","share","Data","name","symbol","uri","sellerFeeBasisPoints","creators","Metadata","mint","editionNonce","init","getEdition","masterEdition","MintPrintingTokensArgs","supply","printingMint","oneTimePrintingAuthorizationMint","ledger","editionTaken","editionOffset","indexOffset","Math","floor","Error","positionInBitsetFromRight","mask","pow","appliedMask","connectOrGetPhantomProvider","connectToWallet","window","provider","solana","isConnected","connect","isPhantom","alert","connectOrGetPhantomProviderTransient","console","log","onlyIfTrusted","dataURLtoFile","dataurl","filename","arr","split","mime","match","bstr","atob","n","length","u8arr","Uint8Array","charCodeAt","File","type","extendBorsh","prototype","readPubkey","reader","array","readFixedArray","writePubkey","value","writer","writeFixedArray","toBuffer","readPubkeyAsString","encode","writePubkeyAsString","decode","mintNFT","connection","env","files","_result$messages","wallet","metadataContent","description","seller_fee_basis_points","image","animation_url","external_url","properties","map","creator","realFiles","JSON","stringify","instructions","pushInstructions","signers","pushSigners","prepPayForFilesTxn","mintRent","getMinimumBalanceForRentExemption","MintLayout","span","payerPublicKey","publicKey","toBase58","mintKey","createMint","recipientKey","findProgramAddress","createAssociatedTokenAccountInstruction","classData","repeat","metadataAccount","createMetadata","txid","sendTransactionWithRetry","confirmTransaction","getParsedConfirmedTransaction","FormData","tags","reduce","acc","f","append","result","fetch","method","body","json","metadataFile","messages","find","m","arweaveLink","transactionId","updateInstructions","updateSigners","updateMetadata","undefined","push","Token","createMintToInstruction","createMasterEdition","account","updateAuthorityKey","mintAuthorityKey","payer","metadataProgramId","Buffer","from","editionAccount","METADATA_SCHEMA","keys","pubkey","isSigner","isWritable","programId","transfer","fromPubkey","toPubkey","lamports","i","hashSum","createHash","update","text","hex","digest","seeds","mintRentExempt","decimals","owner","freezeAuthority","createUninitializedMint","createInitMintInstruction","createTokenAccount","accountRentExempt","createUninitializedAccount","createInitAccountInstruction","amount","generate","createAccount","newAccountPubkey","space","AccountLayout","associatedTokenAddress","walletAddress","splTokenMintAddress","commitment","arguments","includesFeePayer","block","beforeSend","transaction","forEach","add","recentBlockhash","getRecentBlockhash","blockhash","setSigners","s","partialSign","signTransaction","slot","sendSignedTransaction","signedTransaction","getUnixTs","Date","getTime","awaitTransactionSignatureConfirmation","timeout","queryStatus","done","status","confirmations","err","subId","Promise","resolve","reject","setTimeout","onSignature","context","e","error","signatureStatuses","getSignatureStatuses","_signatureSubscriptions","removeSignatureListener","_ref","rawTransaction","startTime","sendRawTransaction","skipPreflight","confirmation","tokenMint","Map","kind","fields","txnData","newUpdateAuthority"],"sources":["/Users/tashapais/Documents/Github/lionhack/src/utils/nftCreation.js"],"sourcesContent":["import { BinaryReader, BinaryWriter } from 'borsh';\nimport base58 from 'bs58';\nimport * as splToken from '@solana/spl-token'\nimport crypto from 'crypto';\nimport BN from 'bn.js';\nimport { serialize } from 'borsh';\nimport {\n    Keypair,\n      PublicKey,\n      Transaction,\n      clusterApiUrl,\n      SystemProgram,\n      SYSVAR_RENT_PUBKEY,\n      TransactionInstruction\n    } from \"@solana/web3.js\";\nimport { sleepUtil } from './sleepUtil';\n\nexport const TOKEN_PROGRAM_ID = new PublicKey(\n  'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n);\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey(\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n);\n\nconst METADATA_PROGRAM_ID =\n    'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s';\n\nconst MEMO_ID = new PublicKey(\n  'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr',\n);\n\nconst programIds = {\n  token: TOKEN_PROGRAM_ID,\n  associatedToken: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  metadata: METADATA_PROGRAM_ID,\n  memo: MEMO_ID,\n}\n\nexport const NETWORK = clusterApiUrl(\"devnet\");\nexport const AR_SOL_HOLDER_ID = new PublicKey(\n    'HvwC9QSAzvGXhhVrgPmauVwFWcYZhne3hVot9EbHuFTm',\n);\nexport const METADATA_PREFIX = 'metadata';\nexport const EDITION = 'edition';\nexport const EDITION_MARKER_BIT_SIZE = 248;\nexport const DEFAULT_TIMEOUT = 15000;\nexport const RESERVED_TXN_MANIFEST = 'manifest.json';\nexport const MetadataKey = {\n    Uninitialized : 0,\n    MetadataV1 : 4,\n    EditionV1 : 1,\n    MasterEditionV1 : 2,\n    MasterEditionV2 : 6,\n    EditionMarker : 7,\n}\n\n/**\n * Classes to be used to create the NFT\n */\n\n class CreateMetadataArgs {\n    instruction= 0;\n    data;\n    isMutable;\n  \n    constructor(args) {\n      this.data = args.data;\n      this.isMutable = args.isMutable;\n    }\n  }\n\n  class UpdateMetadataArgs {\n    instruction= 1;\n    data;\n    // Not used by this app, just required for instruction\n    updateAuthority;\n    primarySaleHappened;\n    constructor(args) {\n      this.data = args.data ? args.data : null;\n      this.updateAuthority = args.updateAuthority ? args.updateAuthority : null;\n      this.primarySaleHappened = args.primarySaleHappened;\n    }\n  }\n\n  class CreateMasterEditionArgs {\n    instruction = 10;\n    maxSupply;\n    constructor(args) {\n      this.maxSupply = args.maxSupply;\n    }\n  }\n\n  class Edition {\n    key;\n    /// Points at MasterEdition struct\n    parent;\n    /// Starting at 0 for master record, this is incremented for each edition minted.\n    edition;\n  \n    constructor(args) {\n      this.key = MetadataKey.EditionV1;\n      this.parent = args.parent;\n      this.edition = args.edition;\n    }\n  }\n  export class Creator {\n    address;\n    verified;\n    share;\n  \n    constructor(args) {\n      this.address = args.address;\n      this.verified = args.verified;\n      this.share = args.share;\n    }\n  }\n  \n  class Data {\n    name;\n    symbol;\n    uri;\n    sellerFeeBasisPoints;\n    creators;\n    constructor(args) {\n      this.name = args.name;\n      this.symbol = args.symbol;\n      this.uri = args.uri;\n      this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;\n      this.creators = args.creators;\n    }\n  }\n  \n  class Metadata {\n    key;\n    updateAuthority;\n    mint;\n    data;\n    primarySaleHappened;\n    isMutable;\n    editionNonce;\n  \n    // set lazy\n    masterEdition;\n    edition;\n  \n    constructor(args) {\n      this.key = MetadataKey.MetadataV1;\n      this.updateAuthority = args.updateAuthority;\n      this.mint = args.mint;\n      this.data = args.data;\n      this.primarySaleHappened = args.primarySaleHappened;\n      this.isMutable = args.isMutable;\n      this.editionNonce = args.editionNonce;\n    }\n  \n    async init() {\n      const edition = await getEdition(this.mint);\n      this.edition = edition;\n      this.masterEdition = edition;\n    }\n  }\n\n  class MintPrintingTokensArgs {\n    instruction9;\n    supply;\n  \n    constructor(args) {\n      this.supply = args.supply;\n    }\n  }\n\n  class MasterEditionV1 {\n    key;\n    supply;\n    maxSupply;\n    /// Can be used to mint tokens that give one-time permission to mint a single limited edition.\n    printingMint;\n    /// If you don't know how many printing tokens you are going to need, but you do know\n    /// you are going to need some amount in the future, you can use a token from this mint.\n    /// Coming back to token metadata with one of these tokens allows you to mint (one time)\n    /// any number of printing tokens you want. This is used for instance by Auction Manager\n    /// with participation NFTs, where we dont know how many people will bid and need participation\n    /// printing tokens to redeem, so we give it ONE of these tokens to use after the auction is over,\n    /// because when the auction begins we just dont know how many printing tokens we will need,\n    /// but at the end we will. At the end it then burns this token with token-metadata to\n    /// get the printing tokens it needs to give to bidders. Each bidder then redeems a printing token\n    /// to get their limited editions.\n    oneTimePrintingAuthorizationMint;\n  \n    constructor(args) {\n      this.key = MetadataKey.MasterEditionV1;\n      this.supply = args.supply;\n      this.maxSupply = args.maxSupply;\n      this.printingMint = args.printingMint;\n      this.oneTimePrintingAuthorizationMint =\n        args.oneTimePrintingAuthorizationMint;\n    }\n  }\n  \n  class MasterEditionV2 {\n    key;\n    supply;\n    maxSupply;\n  \n    constructor(args) {\n      this.key = MetadataKey.MasterEditionV2;\n      this.supply = args.supply;\n      this.maxSupply = args.maxSupply;\n    }\n  }\n\n  class EditionMarker {\n    key;\n    ledger;\n  \n    constructor(args) {\n      this.key = MetadataKey.EditionMarker;\n      this.ledger = args.ledger;\n    }\n  \n    editionTaken(edition) {\n      const editionOffset = edition % EDITION_MARKER_BIT_SIZE;\n      const indexOffset = Math.floor(editionOffset / 8);\n  \n      if (indexOffset > 30) {\n        throw Error('bad index for edition');\n      }\n  \n      const positionInBitsetFromRight = 7 - (editionOffset % 8);\n  \n      const mask = Math.pow(2, positionInBitsetFromRight);\n  \n      const appliedMask = this.ledger[indexOffset] & mask;\n  \n      return appliedMask != 0;\n    }\n  }\n\n\n\n/**\n * Helpder function to detect whether Phantom wallet extension installed or not\n * @param {*} connectToWallet \n * @returns \n */\nexport const connectOrGetPhantomProvider = (connectToWallet) => {\n    if (\"solana\" in window) {\n      const provider = window.solana;\n      if(connectToWallet && !window.solana.isConnected){\n            window.solana.connect();\n        }\n        if (provider.isPhantom) {\n            return provider;\n        }\n    }else if(connectToWallet){\n      alert(`Please install the phantom wallet from https://phantom.app/`);\n    }\n    \n};\n\nexport const connectOrGetPhantomProviderTransient = () => {\n  console.log(' connect connectOrGetPhantomProviderTransient called ')\n  if (\"solana\" in window) {\n          window.solana.connect({ onlyIfTrusted: true });\n  }\n}\n\n/**\n * Helper function to convert base64 to file object\n * @param {*} dataurl \n * @param {*} filename \n * @returns \n */\nexport const dataURLtoFile = (dataurl, filename) => {\n    let arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],\n        bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);\n        while(n--){\n            u8arr[n] = bstr.charCodeAt(n);\n        }\n        return new File([u8arr], filename, {type:mime});\n}\n\n/**\n * Utility to add functionality to BinaryReader\n */\nexport const extendBorsh = () => {\n(BinaryReader.prototype).readPubkey = function () {\n    const reader = this;\n    const array = reader.readFixedArray(32);\n    return new PublicKey(array);\n};\n\n(BinaryWriter.prototype).writePubkey = function (value) {\n    const writer = this;\n    writer.writeFixedArray(value.toBuffer());\n};\n\n(BinaryReader.prototype).readPubkeyAsString = function () {\n    const reader = this;\n    const array = reader.readFixedArray(32);\n    return base58.encode(array);\n};\n\n(BinaryWriter.prototype).writePubkeyAsString = function (\n    value,\n) {\n    const writer = this;\n    writer.writeFixedArray(base58.decode(value));\n};\n};\nextendBorsh();\n\n\n\n\n  export const mintNFT = async function(\n    connection,\n    provider,\n    env,\n    files,\n    metadata){\n\n    const wallet = provider\n    const metadataContent = {\n          name: metadata.name,\n          symbol: metadata.symbol,\n          description: metadata.description,\n          seller_fee_basis_points: metadata.sellerFeeBasisPoints,\n          image: metadata.image,\n          animation_url: metadata.animation_url,\n          external_url: metadata.external_url,\n          properties: {\n            ...metadata.properties,\n            creators: metadata.creators.map(creator => {\n              return {\n                address: creator.address,\n                share: creator.share,\n              };\n            }),\n          },\n      };\n    const realFiles = [\n      ...files,\n      new File([JSON.stringify(metadataContent)], 'metadata.json'),\n    ];\n\n    const { instructions: pushInstructions, signers: pushSigners } = await prepPayForFilesTxn(wallet, realFiles, metadata);\n\n\n     // Allocate memory for the account\n    const mintRent = await connection.getMinimumBalanceForRentExemption(\n      splToken.MintLayout.span\n    );\n\n    const payerPublicKey = wallet.publicKey.toBase58();\n    const instructions = [...pushInstructions];\n    const signers = [...pushSigners];\n\n     // This is only temporarily owned by wallet...transferred to program by createMasterEdition below\n    const mintKey = createMint(\n      instructions,\n      wallet.publicKey,\n      mintRent,\n      0,\n      // Some weird bug with phantom where it's public key doesnt mesh with data encode wellff\n      new PublicKey(payerPublicKey),\n      new PublicKey(payerPublicKey),\n      signers,\n    ).toBase58();\n\n    const recipientKey = (\n      await findProgramAddress(\n        [\n          wallet.publicKey.toBuffer(),\n          programIds.token.toBuffer(),\n          new PublicKey(mintKey).toBuffer(),\n        ],\n        programIds.associatedToken,\n      )\n    )[0];\n\n    createAssociatedTokenAccountInstruction(\n      instructions,\n      new PublicKey(recipientKey),\n      wallet.publicKey,\n      wallet.publicKey,\n      new PublicKey(mintKey),\n    );\n    const classData = new Data({\n      symbol: metadata.symbol,\n      name: metadata.name,\n      uri:' '.repeat(64), // size of url for arweave\n      sellerFeeBasisPoints: metadata.sellerFeeBasisPoints,\n      creators: metadata.creators,\n    })\n    const metadataAccount = await createMetadata(\n      classData,\n      payerPublicKey,\n      mintKey,\n      payerPublicKey,\n      instructions,\n      wallet.publicKey.toBase58(),\n    );\n    const { txid } = await sendTransactionWithRetry(\n      connection,\n      wallet,\n      instructions,\n      signers,\n    );\n    try {\n      // return\n     await connection.confirmTransaction(txid, 'max');\n    } catch {\n      // ignore\n    }\n\n    await connection.getParsedConfirmedTransaction(txid, 'confirmed');\n\n    const data = new FormData();\n\n    const tags = realFiles.reduce(\n      (acc, f) => {\n        acc[f.name] = [{ name: 'mint', value: mintKey }];\n        return acc;\n      },\n      {},\n    );\n    data.append('tags', JSON.stringify(tags));\n    data.append('transaction', txid);\n    realFiles.map(f => data.append('file[]', f));\n\n    const result = await (\n      await fetch(\n        'https://us-central1-principal-lane-200702.cloudfunctions.net/uploadFile2',\n        {\n          method: 'POST',\n          body: data,\n        },\n      )\n    ).json();\n\n    const metadataFile = result.messages?.find(\n      m => m.filename === RESERVED_TXN_MANIFEST,\n    );\n    let arweaveLink = \"\"\n    if(metadataFile?.transactionId){\n      const updateInstructions = [];\n    const updateSigners= [];\n    arweaveLink = `https://arweave.net/${metadataFile.transactionId}`;\n    await updateMetadata(\n      new Data({\n        name: metadata.name,\n        symbol: metadata.symbol,\n        uri: arweaveLink,\n        creators: metadata.creators,\n        sellerFeeBasisPoints: metadata.sellerFeeBasisPoints,\n      }),\n      undefined,\n      undefined,\n      mintKey,\n      payerPublicKey,\n      updateInstructions,\n      metadataAccount,\n    );\n\n    updateInstructions.push(\n      splToken.Token.createMintToInstruction(\n        TOKEN_PROGRAM_ID,\n        new PublicKey(mintKey),\n        new PublicKey(recipientKey),\n        new PublicKey(payerPublicKey),\n        [],\n        1,\n      ),\n    );\n\n    await createMasterEdition(\n      new BN(1),\n      mintKey,\n      payerPublicKey,\n      payerPublicKey,\n      payerPublicKey,\n      updateInstructions,\n    );\n\n    await sendTransactionWithRetry(\n      connection,\n      wallet,\n      updateInstructions,\n      updateSigners,\n    );}\n    return { metadataAccount, arweaveLink, mintKey, account: recipientKey };\n  }\n\n  //END the mintNFT\n\n  /**\n   * \n   * @param {*} maxSupply \n   * @param {*} mintKey \n   * @param {*} updateAuthorityKey \n   * @param {*} mintAuthorityKey \n   * @param {*} payer \n   * @param {*} instructions \n   */\n\n  async function createMasterEdition(\n    maxSupply,\n    mintKey,\n    updateAuthorityKey,\n    mintAuthorityKey,\n    payer,\n    instructions,\n  ) {\n    const metadataProgramId = programIds.metadata;\n  \n    const metadataAccount = (\n      await findProgramAddress(\n        [\n          Buffer.from(METADATA_PREFIX),\n          new PublicKey(metadataProgramId).toBuffer(),\n          new PublicKey(mintKey).toBuffer(),\n        ],\n        new PublicKey(metadataProgramId),\n      )\n    )[0];\n  \n    const editionAccount = (\n      await findProgramAddress(\n        [\n          Buffer.from(METADATA_PREFIX),\n          new PublicKey(metadataProgramId).toBuffer(),\n          new PublicKey(mintKey).toBuffer(),\n          Buffer.from(EDITION),\n        ],\n        new PublicKey(metadataProgramId),\n      )\n    )[0];\n  \n    const value = new CreateMasterEditionArgs({ maxSupply: maxSupply || null });\n    const data = Buffer.from(serialize(METADATA_SCHEMA, value));\n  \n    const keys = [\n      {\n        pubkey: new PublicKey(editionAccount),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: new PublicKey(mintKey),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: new PublicKey(updateAuthorityKey),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: new PublicKey(mintAuthorityKey),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: new PublicKey(payer),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: new PublicKey(metadataAccount),\n        isSigner: false,\n        isWritable: false,\n      },\n  \n      {\n        pubkey: programIds.token,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n  \n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: new PublicKey(metadataProgramId),\n        data,\n      }),\n    );\n  }\n\n  const prepPayForFilesTxn = async (\n    wallet,\n    files,\n    metadata,\n  ) => {\n    const memo = programIds.memo;\n  \n    const instructions= [];\n    const signers= [];\n  \n    if (wallet.publicKey)\n      instructions.push(\n        SystemProgram.transfer({\n          fromPubkey: wallet.publicKey,\n          toPubkey: AR_SOL_HOLDER_ID,\n          lamports: 100000000,\n        }),\n      );\n  \n    //Already uploading files on IPFS, hence no files to be transacted here\n    for (let i = 0; i < files.length; i++) {\n      const hashSum = crypto.createHash('sha256');\n      hashSum.update(await files[i].text());\n      const hex = hashSum.digest('hex');\n      instructions.push(\n        new TransactionInstruction({\n          keys: [],\n          programId: memo,\n          data: Buffer.from(hex),\n        }),\n      );\n    }\n  \n    return {\n      instructions,\n      signers,\n    };\n  };\n\n  const findProgramAddress = async (\n    seeds,\n    programId,\n  ) => {\n    const result = await PublicKey.findProgramAddress(seeds, programId);\n    return [result[0].toBase58(), result[1]];\n  };\n\n  function createMint(\n    instructions,\n    payer,\n    mintRentExempt,\n    decimals,\n    owner,\n    freezeAuthority,\n    signers,\n  ) {\n    const account = createUninitializedMint(\n      instructions,\n      payer,\n      mintRentExempt,\n      signers,\n    );\n  \n    instructions.push(\n      splToken.Token.createInitMintInstruction(\n        TOKEN_PROGRAM_ID,\n        account,\n        decimals,\n        owner,\n        freezeAuthority,\n      ),\n    );\n  \n    return account;\n  }\n\n  const createTokenAccount =(\n    instructions,\n    payer,\n    accountRentExempt,\n    mint,\n    owner,\n    signers,\n  ) => {\n    const account = createUninitializedAccount(\n      instructions,\n      payer,\n      accountRentExempt,\n      signers,\n    );\n  \n    instructions.push(\n      splToken.Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, account, owner),\n    );\n  \n    return account;\n  }\n\n  function createUninitializedMint(\n    instructions,\n    payer,\n    amount,\n    signers,\n  ) {\n    const account = Keypair.generate();\n    instructions.push(\n      SystemProgram.createAccount({\n        fromPubkey: payer,\n        newAccountPubkey: account.publicKey,\n        lamports: amount,\n        space: splToken.MintLayout.span,\n        programId: TOKEN_PROGRAM_ID,\n      }),\n    );\n  \n    signers.push(account);\n  \n    return account.publicKey;\n  }\n\n  function createUninitializedAccount(\n    instructions,\n    payer,\n    amount,\n    signers,\n  ) {\n    const account = Keypair.generate();\n    instructions.push(\n      SystemProgram.createAccount({\n        fromPubkey: payer,\n        newAccountPubkey: account.publicKey,\n        lamports: amount,\n        space: splToken.AccountLayout.span,\n        programId: TOKEN_PROGRAM_ID,\n      }),\n    );\n  \n    signers.push(account);\n  \n    return account.publicKey;\n  }\n\n  function createAssociatedTokenAccountInstruction(\n    instructions,\n    associatedTokenAddress,\n    payer,\n    walletAddress,\n    splTokenMintAddress,\n  ) {\n    const keys = [\n      {\n        pubkey: payer,\n        isSigner: true,\n        isWritable: true,\n      },\n      {\n        pubkey: associatedTokenAddress,\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: walletAddress,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: splTokenMintAddress,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: programIds.token,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: programIds.associatedToken,\n        data: Buffer.from([]),\n      }),\n    );\n  }\n\n  const sendTransactionWithRetry = async (\n    connection,\n    wallet,\n    instructions,\n    signers,\n    commitment = 'singleGossip',\n    includesFeePayer = false,\n    block,\n    beforeSend,\n  ) => {\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = (\n      block || (await connection.getRecentBlockhash(commitment))\n    ).blockhash;\n  \n    if (includesFeePayer) {\n      transaction.setSigners(...signers.map(s => s.publicKey));\n    } else {\n      transaction.setSigners(\n        // fee payed by the wallet owner\n        wallet.publicKey,\n        ...signers.map(s => s.publicKey),\n      );\n    }\n  \n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n    if (!includesFeePayer) {\n      transaction = await wallet.signTransaction(transaction);\n    }\n  \n    if (beforeSend) {\n      beforeSend();\n    }\n  \n    const { txid, slot } = await sendSignedTransaction({\n      connection,\n      signedTransaction: transaction,\n    });\n  \n    return { txid, slot };\n  };\n  const getUnixTs = () => {\n    return new Date().getTime() / 1000;\n  };\n\n  async function awaitTransactionSignatureConfirmation(\n    txid,\n    timeout,\n    connection,\n    commitment = 'recent',\n    queryStatus = false,\n  ) {\n    let done = false;\n    let status = {\n      slot: 0,\n      confirmations: 0,\n      err: null,\n    };\n    let subId = 0;\n    status = await new Promise(async (resolve, reject) => {\n      setTimeout(() => {\n        if (done) {\n          return;\n        }\n        done = true;\n        console.log('Rejecting for timeout...');\n        reject({ timeout: true });\n      }, timeout);\n      try {\n        subId = connection.onSignature(\n          txid,\n          (result, context) => {\n            done = true;\n            status = {\n              err: result.err,\n              slot: context.slot,\n              confirmations: 0,\n            };\n            if (result.err) {\n              console.log('Rejected via websocket', result.err);\n              reject(status);\n            } else {\n              console.log('Resolved via websocket', result);\n              resolve(status);\n            }\n          },\n          commitment,\n        );\n      } catch (e) {\n        done = true;\n        console.error('WS error in setup', txid, e);\n      }\n      while (!done && queryStatus) {\n        // eslint-disable-next-line no-loop-func\n        (async () => {\n          try {\n            const signatureStatuses = await connection.getSignatureStatuses([\n              txid,\n            ]);\n            status = signatureStatuses && signatureStatuses.value[0];\n            if (!done) {\n              if (!status) {\n                console.log('REST null result for', txid, status);\n              } else if (status.err) {\n                console.log('REST error for', txid, status);\n                done = true;\n                reject(status.err);\n              } else if (!status.confirmations) {\n                console.log('REST no confirmations for', txid, status);\n              } else {\n                console.log('REST confirmation for', txid, status);\n                done = true;\n                resolve(status);\n              }\n            }\n          } catch (e) {\n            if (!done) {\n              console.log('REST connection error: txid', txid, e);\n            }\n          }\n        })();\n        await sleepUtil(1000);\n      }\n    });\n  \n    //@ts-ignore\n    if (connection._signatureSubscriptions[subId])\n      connection.removeSignatureListener(subId);\n    done = true;\n    console.log('Returning status', status);\n    return status;\n  }\n\n  async function sendSignedTransaction({\n    signedTransaction,\n    connection,\n    timeout = DEFAULT_TIMEOUT,\n  }){\n    const rawTransaction = signedTransaction.serialize();\n    const startTime = getUnixTs();\n    let slot = 0;\n    const txid = await connection.sendRawTransaction(\n      rawTransaction,\n      {\n        skipPreflight: true,\n      },\n    );\n  \n    console.log('Started awaiting confirmation for', txid);\n  \n    let done = false;\n    (async () => {\n      while (!done && getUnixTs() - startTime < timeout) {\n        connection.sendRawTransaction(rawTransaction, {\n          skipPreflight: true,\n        });\n        await sleepUtil(500);\n      }\n    })();\n    try {\n      const confirmation = await awaitTransactionSignatureConfirmation(\n        txid,\n        timeout,\n        connection,\n        'recent',\n        true,\n      );\n  \n      if (!confirmation)\n        throw new Error('Timed out awaiting confirmation on transaction');\n  \n      if (confirmation.err) {\n        console.error(confirmation.err);\n        throw new Error('Transaction failed: Custom instruction error');\n      }\n  \n      slot = confirmation?.slot || 0;\n    } catch (err) {\n      // console.error('Timeout Error caught', err);\n      // if (err.timeout) {\n      //   throw new Error('Timed out awaiting confirmation on transaction');\n      // }\n      // let simulateResult: SimulatedTransactionResponse | null = null;\n      // try {\n      //   simulateResult = (\n      //     await simulateTransaction(connection, signedTransaction, 'single')\n      //   ).value;\n      // } catch (e) {}\n      // if (simulateResult && simulateResult.err) {\n      //   if (simulateResult.logs) {\n      //     for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n      //       const line = simulateResult.logs[i];\n      //       if (line.startsWith('Program log: ')) {\n      //         throw new Error(\n      //           'Transaction failed: ' + line.slice('Program log: '.length),\n      //         );\n      //       }\n      //     }\n      //   }\n      //   throw new Error(JSON.stringify(simulateResult.err));\n      // }\n      // throw new Error('Transaction failed');\n    } finally {\n      done = true;\n    }\n  \n    console.log('Latency', txid, getUnixTs() - startTime);\n    return { txid, slot };\n  }\n\n  async function getEdition(\n    tokenMint,\n  ){    \n    return (\n      await findProgramAddress(\n        [\n          Buffer.from(METADATA_PREFIX),\n          new PublicKey(programIds.metadata).toBuffer(),\n          new PublicKey(tokenMint).toBuffer(),\n          Buffer.from(EDITION),\n        ],\n        new PublicKey(programIds.metadata),\n      )\n    )[0];\n  }\n  \n  const METADATA_SCHEMA = new Map([\n    [\n      CreateMetadataArgs,\n      {\n        kind: 'struct',\n        fields: [\n          ['instruction', 'u8'],\n          ['data', Data],\n          ['isMutable', 'u8'], // bool\n        ],\n      },\n    ],\n    [\n      UpdateMetadataArgs,\n      {\n        kind: 'struct',\n        fields: [\n          ['instruction', 'u8'],\n          ['data', { kind: 'option', type: Data }],\n          ['updateAuthority', { kind: 'option', type: 'pubkeyAsString' }],\n          ['primarySaleHappened', { kind: 'option', type: 'u8' }],\n        ],\n      },\n    ],\n  \n    [\n      CreateMasterEditionArgs,\n      {\n        kind: 'struct',\n        fields: [\n          ['instruction', 'u8'],\n          ['maxSupply', { kind: 'option', type: 'u64' }],\n        ],\n      },\n    ],\n    [\n      MintPrintingTokensArgs,\n      {\n        kind: 'struct',\n        fields: [\n          ['instruction', 'u8'],\n          ['supply', 'u64'],\n        ],\n      },\n    ],\n    [\n      MasterEditionV1,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['supply', 'u64'],\n          ['maxSupply', { kind: 'option', type: 'u64' }],\n          ['printingMint', 'pubkeyAsString'],\n          ['oneTimePrintingAuthorizationMint', 'pubkeyAsString'],\n        ],\n      },\n    ],\n    [\n      MasterEditionV2,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['supply', 'u64'],\n          ['maxSupply', { kind: 'option', type: 'u64' }],\n        ],\n      },\n    ],\n    [\n      Edition,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['parent', 'pubkeyAsString'],\n          ['edition', 'u64'],\n        ],\n      },\n    ],\n    [\n      Data,\n      {\n        kind: 'struct',\n        fields: [\n          ['name', 'string'],\n          ['symbol', 'string'],\n          ['uri', 'string'],\n          ['sellerFeeBasisPoints', 'u16'],\n          ['creators', { kind: 'option', type: [Creator] }],\n        ],\n      },\n    ],\n    [\n      Creator,\n      {\n        kind: 'struct',\n        fields: [\n          ['address', 'pubkeyAsString'],\n          ['verified', 'u8'],\n          ['share', 'u8'],\n        ],\n      },\n    ],\n    [\n      Metadata,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['updateAuthority', 'pubkeyAsString'],\n          ['mint', 'pubkeyAsString'],\n          ['data', Data],\n          ['primarySaleHappened', 'u8'], // bool\n          ['isMutable', 'u8'], // bool\n        ],\n      },\n    ],\n    [\n      EditionMarker,\n      {\n        kind: 'struct',\n        fields: [\n          ['key', 'u8'],\n          ['ledger', [31]],\n        ],\n      },\n    ],\n  ]);\n\n  async function createMetadata(\n    data,\n    updateAuthority,\n    mintKey,\n    mintAuthorityKey,\n    instructions,\n    payer,\n  ) {\n    const metadataProgramId = programIds.metadata;\n    const metadataAccount = (\n      await findProgramAddress(\n        [\n          Buffer.from('metadata'),\n          new PublicKey(metadataProgramId).toBuffer(),\n          new PublicKey(mintKey).toBuffer(),\n        ],\n        new PublicKey(metadataProgramId),\n      )\n    )[0];\n    \n    const value = new CreateMetadataArgs({ data, isMutable: true });\n\n    let txnData = Buffer.from(serialize(METADATA_SCHEMA, value));;\n    const keys = [\n      {\n        pubkey: new PublicKey(metadataAccount),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: new PublicKey(mintKey),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: new PublicKey(mintAuthorityKey),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: new PublicKey(payer),\n        isSigner: true,\n        isWritable: false,\n      },\n      {\n        pubkey: new PublicKey(updateAuthority),\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n      {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: new PublicKey(metadataProgramId),\n        data: txnData,\n      }),\n    );\n  \n    return metadataAccount;\n  }\n\n  async function updateMetadata(\n    data,\n    newUpdateAuthority,\n    primarySaleHappened,\n    mintKey,\n    updateAuthority,\n    instructions,\n    metadataAccount,\n  ) {\n    const metadataProgramId = programIds.metadata;\n  \n    metadataAccount =\n      metadataAccount ||\n      (\n        await findProgramAddress(\n          [\n            Buffer.from('metadata'),\n            new PublicKey(metadataProgramId).toBuffer(),\n            new PublicKey(mintKey).toBuffer(),\n          ],\n          new PublicKey(metadataProgramId),\n        )\n      )[0];\n\n    const value = new UpdateMetadataArgs({\n      data,\n      updateAuthority: !newUpdateAuthority ? undefined : newUpdateAuthority,\n      primarySaleHappened:\n        primarySaleHappened === null || primarySaleHappened === undefined\n          ? null\n          : primarySaleHappened,\n    });\n    const txnData = Buffer.from(serialize(METADATA_SCHEMA, value));\n    const keys = [\n      {\n        pubkey: new PublicKey(metadataAccount),\n        isSigner: false,\n        isWritable: true,\n      },\n      {\n        pubkey: new PublicKey(updateAuthority),\n        isSigner: true,\n        isWritable: false,\n      },\n    ];\n    instructions.push(\n      new TransactionInstruction({\n        keys,\n        programId: new PublicKey(metadataProgramId),\n        data: txnData,\n      }),\n    );\n  \n    return metadataAccount;\n  }"],"mappings":"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"},"metadata":{},"sourceType":"module"}